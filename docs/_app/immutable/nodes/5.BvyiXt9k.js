import{f as p,a as o}from"../chunks/Cn_zYDD-.js";import"../chunks/GIYq9FUk.js";import{$ as n,a3 as v,_ as g,a4 as f,a5 as y,a6 as a,a1 as c,a2 as r}from"../chunks/BNExFjTs.js";import{h as U}from"../chunks/C5iu_Ixj.js";import{s as l}from"../chunks/ByWjJamm.js";import{b as i}from"../chunks/BW_lLanF.js";const R=!0,T=Object.freeze(Object.defineProperty({__proto__:null,prerender:R},Symbol.toStringTag,{value:"Module"}));var z=p('<meta name="description" content="The definitive guide to when and why you must use encodeURIComponent instead of encodeURI — with real examples that break when you choose wrong."/> <meta property="og:title" content="encodeURIComponent vs encodeURI: Never Mix Them Up Again"/> <meta property="og:description" content="The definitive guide to when and why you must use encodeURIComponent instead of encodeURI."/> <meta property="og:url"/> <meta property="og:type" content="article"/> <meta name="twitter:card" content="summary_large_image"/>',1),I=p(`<div class="container fade-in post-layout svelte-1apmzc4"><div class="breadcrumbs svelte-1apmzc4"><a class="svelte-1apmzc4">Blog</a> <span>/</span> <p class="svelte-1apmzc4">encodeURIComponent vs encodeURI</p></div> <article class="prose svelte-1apmzc4"><h1 class="svelte-1apmzc4">encodeURIComponent vs encodeURI: Never Mix Them Up Again</h1> <p class="post-meta svelte-1apmzc4">Published: November 20, 2025</p> <p class="svelte-1apmzc4">These two functions look almost identical — yet choosing the wrong one is the #1 cause of broken query strings and 400 Bad Request errors.</p> <h2 class="svelte-1apmzc4">The Critical Difference</h2> <p class="svelte-1apmzc4">encodeURI() assumes the string is a full URL and leaves slashes, colons, and question marks intact.  
    encodeURIComponent() assumes the string is a single component (like a query value) and encodes everything that could break parsing — including &, ?, =, and /.</p> <h2 class="svelte-1apmzc4">Real Example That Breaks</h2> <p class="svelte-1apmzc4">Search term: “cats & dogs”  
    Correct: ?q=encodeURIComponent("cats & dogs") → ?q=cats%20%26%20dogs  
    Wrong: ?q=encodeURI("cats & dogs") → ?q=cats%20&%20dogs → splits into q=cats and dogs= (empty)</p> <h2 class="svelte-1apmzc4">Quick Rule of Thumb</h2> <ul><li>Use encodeURI() only when building a complete URL from safe parts</li> <li>Use encodeURIComponent() for every query parameter value and path segment</li> <li>When in doubt → encodeURIComponent()</li></ul> <h2 class="svelte-1apmzc4">FAQ</h2> <details class="svelte-1apmzc4"><summary class="svelte-1apmzc4">Why does encodeURI exist at all?</summary> <p class="svelte-1apmzc4">For safely encoding entire URLs when you already know the structure is valid (rare in practice).</p></details> <details class="svelte-1apmzc4"><summary class="svelte-1apmzc4">Does this tool use the correct one?</summary> <p class="svelte-1apmzc4">Yes — it always uses encodeURIComponent() + proper handling of reserved chars for maximum safety.</p></details> <p class="italic-note svelte-1apmzc4">One wrong function call = hours of debugging. Bookmark this page.</p></article></div>`);function x(m){var e=I();U("1apmzc4",u=>{var t=z(),h=v(g(t),6);a(4),n(()=>l(h,"content",`${i??""}/blog/posts/post2`)),f(()=>{y.title="encodeURIComponent vs encodeURI: Never Mix Them Up Again"}),o(u,t)});var s=c(e),d=c(s);a(4),r(s),a(2),r(e),n(()=>l(d,"href",`${i??""}/blog`)),o(m,e)}export{x as component,T as universal};
